####1项目准备
	1、安装vue-cli3：npm install -g @vue/cli
	   创建项目：“vue create gshop-client    // 自动下载所有依赖
	   cd gshop-client
	   npm run serve
####请求、响应拦截器
	// Add a request interceptor
	axios.interceptors.request.use(function (config) {
   	   // Do something before request is sent
  	    return config;
  	}, function (error) {
   	   // Do something with request error
   	   return Promise.reject(error);
 	   });

	// Add a response interceptor
	axios.interceptors.response.use(function (response) {
    	  // Do something with response data
    	  return response;
  	}, function (error) {
    	  // Do something with response error
    	  return Promise.reject(error);
  	});
	
####axios中的默认值配置全局
	// 配置默认值
	// 你可以指定将应用于每个请求的配置默认值。
	
	// 全局axios默认值
	axios.defaults.baseURL = 'http://localhost:5000'

	// 请求超时的语法，超过20秒进入失败的逻辑
	axios.defaults.timeout = 20000
	
####创建Swiper时机：必须在列表页面显示之后，解决swiper的bug--创建swiper轮播图有问题
	1、watch+ nextTick
	watch: {
    // vue的机制：更新状态数据===>调用监视的回调==>异步更新界面
    // 监视categorys的数据变化：数组请求到
    categorys() {
      // 将回调延迟到下次DOM更新循环之后执行，在修改数据后立即使用它
      this.$nextTick(() => {
        // 创建Swiper时机：必须在列表页面显示之后
        // swiper使用：
        // 先下载安装，然后引入swiper、css，再new 一个swiper
        // 参数：第一个：容器；第二个配置对象
        new Swiper('.swiper-container', {
          loop: true, // 循环模式
          // 如果需要分页器
          pagination: {
            el: '.swiper-pagination'
          }
        })
      })
    }
  },
	2、自定义回调callback  +nextTick
	// 在dispatch的时候，传入一个callback，
	this.$store.dispatch('getCategorys', () => {
      // categorys变化了
      this.$nextTick(() => {
        new Swiper('.swiper-container', {
          loop: true, // 循环模式
          // 如果需要分页器
          pagination: {
            el: '.swiper-pagination'
          }
        })
      })
    })
	
	3、利用dispatch返回的promise，promise对象是在状态更新切界面更新之后才产生promise成功的结果
	// 利用：dispatch返回的是一个promise对象
	// promise对象是在状态更新切界面更新之后才产生promise成功的结果
    async mounted() {
		this.$store.dispatch('getShops')
		// 只有到await得到一个成功状态的promise之后，才执行下面的代码
		await this.$store.dispatch('getCategorys')
		new Swiper('.swiper-container', {
			loop: true, // 循环模式
			// 如果需要分页器
			pagination: {
				el: '.swiper-pagination'
			}
		})
	},
	在actions中对应的action函数中，在commit之后调用该函数。
	 // 获取分类列表的数组
	async getCategorys ({ commit }, callback) {
		// 1、发送异步请求数据
		const result = await reqGetCategorys()
		if (result.code === 0) {
		  const categorys = result.data
		  // 2、拿到数据更新state中的数据
          commit(RECEIVE_CATEGORYS, categorys)
         // 在commit之后，因为commit更新数据，
         // 在数据更新之后调用，类似于watch
         // 严格来说传了个函数，并且存在。再调用。防止没有报错
         typeof callback === 'function' && callback()
    }
  },
  
####控制台报错：touch事件原因：使用第三方库：swiper轮播图滑动的时候
	Unable to preventDefault inside passive event listener due to target being treated as passive.
	解决方法：
	1、全局css样式中添加：方便好找
	* {
		touch-action: none;
		或者下面的这句：这两句都可以
		touch-action: pan-y;
	}
	2、设置touchmove方法增加参数{passive: true },因为touchmove方法可能定义在第三方框架中,不容易修改

	wnidow.addEventListener('touchmove', func) 
	修改为：
	wnidow.addEventListener('touchmove', func, { passive: false})
	
	
####dispatch返回的是一个promise对象
	是在状态更新切界面更新之后才产生promise成功的结果
	
	
####vue脚手架----hmr     热模替换
	只编译修改了的模块部分；
	https://blog.csdn.net/pedrojuliet/article/details/81701406
	
####vue项目报错
	GET http://localhost:8080/sockjs-node/info?t=1567409647931 net::ERR_CONNECTION_REFUSED 
	
	解决方式：gitHubl上自己去看
	https://github.com/JollyC1owN/webpack-dev-server

####路由中的meta
	在配置路由的routes中：
	{
		path: '/msite',
		component: Msite,
		// meta:它会保存在$route中，在组件中可以通过$route.meta.xxx读取
		meta: {
			showFooter: true
		}
	}
	
####发请求---dispatch（）在App组件中：在切换App中的路由组件时，不用再发请求，因为路由组件在切换时，是创建与死亡的操作；
	在父组件中发送请求，可以减少请求的次数；在路由组件中写请求，也是可以的，每次都获取最新的数据
	
####json的理解
	1、json的整体结构
		json对象：{}
		json数组：[]
	2、内部结构
		{key1:value1,key12:value2}
		[value1,value2,value3]
		key:字符串，必须用双引号包起来
		value：string/number/boolean/{}/[]
	3、json与js的关系
		json本身是一种特定格式的js字符串
		json对象与js对象可以相互转换
		json数组与js数组可以相互转换
	4、问题：mock的json数据与真实接口数据的关系
		-结构：数据的类型和名称
		-值（数据）：
		结构要一样，而值可以不一样 ---最理想的状态
####给响应式对象新添加的属性不要具有响应式的处理方法
	在全局执行：
		Vue.set(响应式对象，新添加的响应式属性--这是一个字符串，属性的值)